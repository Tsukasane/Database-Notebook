# 数据库笔记（BNU MOOC版）

## Chapter 7 数据库设计：属性-联系方法

[TOC]

### 7.1 数据依赖

* 数据库中所保存的数据值是对现实世界状态的反映，无论现实世界的状态如何变化，一个关系模式中不同属性在取值上总会存在相互依赖又相互制约，这种属性与属性之间的联系，称为数据依赖。
* 数据依赖是**属性-联系数据库**设计方法的基础

#### 数据依赖种类

* 函数依赖
  * 具有实用价值，最重要的数据依赖。
  * 属性$A_{i}$决定属性$A_{j}$，$A_{i} \rightarrow A_{j}$
* 多值依赖
* 联接依赖

#### 逻辑蕴涵

* 定义：给定关系模式S的**函数依赖集D**，可以证明其它一些函数依赖也成立，就称这些**被证明成立的函数依赖是被D逻辑蕴涵**
* 闭包：给定关系模式S的函数依赖集D，D**逻辑蕴涵的所有函数依赖的集合称为D的闭包**，记作$D^+$

#### Armstrong公理

* 反射律：若$A_{j} \subseteq A_{i}$，则 $A_i \rightarrow A_j$
* 增广律：若$A_i \rightarrow A_j$，则$A_iA_k \rightarrow A_jA_k$
* 传递律：若$A_i \rightarrow A_j$，$A_j \rightarrow A_k$，则$A_i \rightarrow A_k$，

#### 三条重要的规则（基于Armstrong公理推出）

<!--关注证明-->

* 合并规则：若$A_i \rightarrow A_j,A_i \rightarrow A_k,$ 	==则== $A_i \rightarrow A_jA_k$
* 分解规则：若$A_i \rightarrow A_jA_k$，==则==$A_i \rightarrow A_j, \quad A_i \rightarrow A_k,$ 
* 伪传递规则：若$A_i \rightarrow A_j,A_jA_l \rightarrow A_k$，==则==$A_iA_l \rightarrow A_k$

#### 最小函数依赖集

* 不同函数依赖集的闭包可能是相等的。 $G^+ = H^+ \Rightarrow $H与G等价，H中的每个函数依赖属于G的闭包，G的每个函数的依赖属于H的闭包。因此==可以只关注函数依赖集中最小函数依赖集==。

* 最小/极小函数依赖集条件：

  1. D中任一函数依赖的右部仅含有一个属性

  2. D中每一个函数依赖的左部都不包含多余的属性

  3. D中不包含多余的依赖（可以由其他依赖推导出就是多余的）

* 每一个函数依赖集**都有**等价的极小函数依赖集$D_m$，一个函数依赖集的极小依赖集**不唯一**

#### 平凡/非平凡函数依赖

* 若$A_i \rightarrow A_j$，但$A_j$不是$A_i$的子集，则称$A_i \rightarrow A_j$ 是**非平凡的函数依赖**
* 若$A_i \rightarrow A_j$，$A_j$是$A_i$的子集，则称$A_i \rightarrow A_j$ 是**平凡的函数依赖**

* 除非特别说明，**一般只考虑非平凡的函数依赖**。



### 7.2 模式分解

* 关系数据库设计的**属性-联系**方法，就是把需要数据库保存的所有属性放在一张关系表中，进而给予数据依赖来优化这个模式，得到期望的结果，这一过程的基本操作就是模式分解。

#### 无损联接与保持依赖

* 是否==无损联接==：元组的增多意味着信息的丢失；分解后自然联接的结果与原表一致则是无损联接。
  * 方法1：使用 **追赶算法** 检验，在过程中，某一行完全变x，则分解具有无损联接性。
  * 方法2：把一个关系模式分解为两个关系模式时，**分解具有无损联接性当且仅当两个关系模式的公共属性是其中一个模式的键**
  * 方法3：分解后两个表的**自然联接**的结果都与原来表中的内容保持一致

* 是否==保持依赖==：如果某个分解能保持函数依赖，那么就可以在分解后的模式上定义等价的完整性约束，在数据输入或更新时，要求每个函数依赖被满足，就可保证数据库中数据的语义完整性。否则，完整性约束会被削弱。
  * 方法：判断**函数依赖的闭包相等**

* 无损联接和保持依赖二者是相互独立的标准，不能互相推出。（保持/不保持共有4种组合方式）
* 一般希望模式分解至少具有无损联接性，才有实际意义，最好也能保持函数依赖。
* 保持函数依赖的分解是关系数据库模式S分解的一个性质，这里$S_i$中的每个函数依赖：直接出现在S分解得到的一个关系模式$S_i$中的$D_i$中，或者由$S_i$中的函数依赖$D_i$推出。

#### 举例（判断函数依赖的个数）

* 设有关系模式$R(A, B, C, D)$

  $F=\{B\rightarrow A, D\rightarrow C\}$，则 $F^{+} $中左部为 $(BC)$ 的函数依赖有 8 个

  因为： $(BC)^+=\{B,C,A\}$ ，$2^3=8$。



### 7.3 范式

#### 分类

* 完全依赖（F）：左侧已经是最小集合

* 部分依赖（P）：存在能达到相同效果的真子集

* 传递依赖（T）：$A \rightarrow B, B\rightarrow C$，则$A\rightarrow C$是传递依赖

* 直接依赖（D）：不存在传递依赖中的B

  完全和直接意味着属性之间的依赖和制约性更强，属性之间的联系更紧密、更亲近；部分和间接则相反。

#### 键基于函数依赖的定义

* **超键**：设K为S<A,D>的属性或属性组，若K决定A，则称K为S的超键
* **候选键**：设K为S<A,D>的超键，若K完全决定A，则称K为S的候选键
* **主键**：若S<A,D>有多个候选键，则可以从中选定一个作为S的主键
* **候选键中的属性，称作主属性**；不包含在任何候选键中的属性称为非主属性
* 实际当中常用的是3NF和BCNF

#### 1～3范式（1～3NF）

* 第1范式：如果关系模式S的每个关系的**每个属性值都是不可分的原子值**，称S是第一范式的模式。**1范式是关系模式起码的条件**。
* 第2范式：如果关系模式S==是1NF==，且每一个==非主属性==都==不部分依赖==于S的任何==候选键==，则S属于2NF。（即非主属性不存在部分依赖关系）**允许存在传递依赖**，是第1和第3中的过度阶段
* 第3范式：如果关系模式S<A,D>==是1NF==，且每个==非主属性==都==既不部分也不传递依赖==于S的任何==候选键==，那么称S是第3范式的模式。

#### BC范式（BCNF）

* 说法一：如果关系模式S<A,D>是==第三范式==，它的任何一个==主属性==都==既不部分也不传递依赖==于S的任何候选键，则称S属于BCNF

* 说法二：如果关系模式S<A,D>（则一定是1NF），它的==任何一个（非主、主）属性既不部分也不传递依赖==于任何==候选键==，则称S属于BCNF

* 说法三：如果关系模式S<A,D>属于1NF，其D中==任意一个非平凡函数依赖的决定因素都包含（候选）键==，则S属于BCNF



### 7.4 规范化

* 规范化：

  一个**较低范式**的关系模式，依据其中的数据依赖、通过**模式分解**可以转换为**高范式**关系模式的集合，这个过程称为规范化。

* 关系模式规范化实际上就是一个模式分解过程：把逻辑上相对独立的信息放在独立的关系模式中。

* 属性分组使**候选键的决定力越纯粹统一**，模式达到的**范式越高**，则对事务处理的支持越强。（BCNF的要求比3NF更高，范式越高，分得越开，保持依赖性越不容易满足）。

* 如果**仅仅要求分解具有无损联接性**，那么**一定能够达到BCNF**。(即不保证保持依赖)。

* 如果要求分解**既具有无损联接性，又具有保持依赖性**，则**一定能够达到3NF**，但**不一定能够达到BCNF**。

* 例子

  * ==无损联接分解关系模式达到BCNF==

    **模式：研究生导师（研究生号，导师号，院系名）**

    * **说明**：每个导师可以指导多名研究生但只能在一个院系工作；每位研究生可以有多位导师，但是在每个院系只能有一个

    * **函数依赖**：(研究生号，导师号)->院系名

      ​					导师号->院系名

      ​					(研究生号，院系名)->导师号

    * **候选键**：(研究生号，导师号)、(研究生号，院系名)

    * **解**：研究生号、导师号、院系名都是主属性，存在“导师号——>院系名”，所以“（研究生号，导师号）——>院系名”是一个主属性对候选键的部分依赖，这说明研究生导师模式不是BCNF

      ​		为了将该模式无损联接地分解为BCNF，首先要初始化，之所以该模式不是BCNF，是因为D中函数依赖“导师号——>院系名”的左部没有包含候选键“（研究生号，导师号）”或“（研究生号，院系名）”。
      ​		将该函数依赖左右两端的属性一起作为一个新的模式并给起名“导师院系”，将研究生导师模式中的属性“院系名”移去后剩下的属性成为一个模式并给起个名字“师生”。这样分解后包括导师院系模式和师生模式，导师院系有函数依赖，师生模式的函数依赖集中没有非平凡的函数依赖，此时导师院系和师生两个关系模式都已经达到BCNF，分解结束。

  * ==无损联接且保持依赖地分解成3NF==

    【例1】**模式：考官院系（考官号，姓名，院系名，院系总人数）**

    * {考官号->姓名，考官号->院系名，院系名->院系总人数}

    * {考官号->(姓名，院系名)，院系名->院系总人数}

    * 考官(考官号，姓名，院系名)、院系(院系名，院系总人数)

      **解**：考官院系不是BCNF，为了保证分解无损联接和保持函数依赖，

    * 首先求解该模式上的函数依赖集的极小依赖集（一共三个依赖）

    * 合并左部相同的函数依赖得到第三行；

    * 分别将这两个函数依赖的两端出现的属性作为单独的模式，并给起上合适的名字就得到两个模式（第四行），原模式“考官院系”的候选键“考官号”已经出现在刚刚产生的“考官”模式中。

    * 总共分解为两个模式，分解结束。

    【例2】**模式：报考（报考号，姓名，试卷号，试卷名）**

    * {报考号->姓名，报考号->试卷名}

    * 考生(报考号，姓名)、试卷(报考号，试卷名)、报考(报考号，试卷号)

      **解**：有关系模式报考，它仅仅是1NF，为了将该模式无损联接且保持依赖地分解以达到3NF
      		首先求解该模式上的函数依赖集的极小依赖集，并合并左部相同的函数依赖，得到第二行；
      		分别将这两个函数依赖两端出现的属性作为单独的模式并给起上合适的名字，得到第三行；
      		原模式“报考”的候选键“（报考号，试卷号）”没有出现在改刚刚产生的两个模式当中，所以单独作为一个模式并且一个合适的名字，总共分为三个模式（第三行）；
      		分解结束。

* 不能简单地说数据冗余就不好，因为数据冗余有利有弊。不能简单地说关系模式满足的范式级别越高越好，因为高范式和低范式各有千秋。在设计数据库模式结构时，必须对现实世界的实际情况和用户应用需求作进一步分析，以选择一个合适的规范化和冗余的折中处理。

​	